## Об'єкти без методів

(Оригінал цієї статті знаходиться [тут](https://www.yegor256.com/2020/11/24/objects-without-methods.html).)

24 листопада 2020 р. Москва, Росія.

Автор: [Єгор Бугаєнко](https://www.yegor256.com).

Як ви думаєте, що таке об'єкт в ООП? На якій мові ви б не програмували, мабуть, ви погодитеся з Брюсом Екелом (Bruce Eckel), автором ["Thinking in Java"](https://amzn.to/3pRHv1Q), який сказав, що "кожен об'єкт має стан і має дії, які можна попросити його виконати", і з Бенджаміном Евансом, автором ["Java in a Nutshell"](https://amzn.to/35uKVPU), який заявив, що об'єкт — це "набір полів даних для збереження значень і методів, які працюють з цими даними". Але хвилинку... Якби я вам сказав, що об'єкт може бути без "операцій" і все-таки залишатися ідеальним "еквівалентом квантів, з яких побудований Всесвіт", як запропонував Дейвід Вест у своїй чудовій книжці [Object Thinking](https://amzn.to/3kuXHlL)?

![The Ballad of Buster Scruggs](/the-ballad-of-buster-scruggs.jpg)
(Image :copyright: The Ballad of Buster Scruggs (2018) by Coen brothers)

Наприклад, тут ми очікуємо, що нам передадуть примірник Java-[інтерфейсу](https://docs.oracle.com/javase/tutorial/java/concepts/interface.html) `Book`:

```java
void print(Book b) {
  System.out.printf(
    "The ISBN is: %s%n", b.isbn()
  );
}
```

Тип `Book` може виглядати так:

```java
interface Book {
  String isbn();
}
```

Якщо об'єкт, який не імплементує інтерфейсу `Book`, передається в метод `print()`, компілятор викине помилку про неузгодження типів (type mismatch). Програмісту важко зробити помилку і передати об'єкт типу, скажімо, `Car` в метод `print()`. І все-таки це можливо при використанні динамічного приведення типів:

```java
Car car = new Car("Mercedes-Benz G63");
print(Book.class.cast(car)); // Отут!
```

Цей код компілюється без помилок, але в час виконання ми отримаємо [виняток `ClassCastException`](https://docs.oracle.com/javase/7/docs/api/java/lang/ClassCastException.html), бо неможливо привести `Car` до типу `Book`.

Краса строгої типізації в тому, що вона запобігає помилкам. Але вона також ускладнює код: спочатку ви маєте створити типи, ви маєте оголосити їх у всіх своїх функціях, вам потрібне приведення типів, а його важко зневадити, і так далі. [Захисники](https://softwareengineering.stackexchange.com/questions/38002) слабкої типізації дуже на це скаржаться і винаходять мови, подібні до Ruby, наприклад:

```ruby
def print(b)
  puts(format("This is ISBN: %s", b.isbn))
end
```

Тут функція `print()` не очікує якогось визначеного типу змінної `b`. Що їй не дай — все добре. Потім, коли настає час викликати `.isbn`, середовище виконання перевіряє, чи `b` має такий метод. Якщо має, все в порядку; якщо ні — видається [помилка часу виконання NoMethodError](https://ruby-doc.org/core-2.5.0/NoMethodError.html).

І ніби все добре.

Але є ідея: а якби ми поєднали простоту і стислість динамічної типізації з безпечністю строгої типізації, викинувши типи зовсім і дозволивши компілятору самому вгадати інформацію про типи з коду, який вживає відповідні об'єкти? Ось наш код знову:

```java
void print(Book b) {
  System.out.printf(
    "The ISBN is: %s%n", b.isbn()
  );
}
```

Подумайте над таким: в час компіляції вже майже очевидно, що `b` мусить мати *щонайменше* один метод — метод `isbn()`. Нема потреби вимагати від програміста визначити тип `Book` і явно вказати в сигнатурі методу `print()`, що ми дозволяємо тільки "книжкові" об'єкти: це легко вгадати, побачивши тіло методу `print()`! Компілятор може поглянути на всі твердження в методі `print()` і чітко *зрозуміти*, що саме має бути зроблено з об'єктом `b`. Цих відомостей повинно вистачити, щоб уявити "тип" об'єкту на вході. Нема потреби просити програміста вказати це явно і додати п'ять рядків коду в новому файлі для визначення типу `Book`. Компілятор може це зробити замість нас.

Звичайно, щоб це впровадити, ми мусимо заборонити будь-яке [приведення типів](https://www.yegor256.com/2015/04/02/class-casting-is-anti-pattern.html), а це неможливо в Java, C++, C# та інших псевдо-об'єктно-орієнтованих мовах. Але це можливо в [EO](https://www.eolang.org/)!

Що скажете?
